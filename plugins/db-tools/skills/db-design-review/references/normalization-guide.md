# 数据库规范化详细指南

## 用最简单的话理解规范化

数据库规范化的核心目标是**消除重复数据**。当同一个信息在多处出现时，更新一处就可能忘记更新其他地方，导致数据不一致。规范化就是把重复的信息拆分到独立的表中，通过ID关联它们。

**"表格参数的独立性"简单解释**：表中每一列（参数）的值应该只由主键决定，不应该由其他非主键列决定。如果A列的值能决定B列的值，那B列就"依赖"A列，这两列就不是独立的——它们应该被拆分到不同的表中。

---

## 第一范式 (1NF)：每个格子只放一个值

### 检查标准

| 检查项 | Yes = 合规 |
|--------|-----------|
| 每个单元格只有一个值？（无逗号分隔列表） | ✅ |
| 表有主键？ | ✅ |
| 没有重复列？（如phone1, phone2, phone3） | ✅ |

### 违规示例

```sql
-- ❌ 违反1NF：tags列存储多个值
| id | title | tags                    |
|----|-------|-------------------------|
| 1  | Post1 | "前端,React,JavaScript" |
```

### 修复方法

创建关联表：

```sql
-- ✅ 符合1NF
posts: id, title
tags: id, name
post_tags: post_id, tag_id
```

### 违规示例 2：重复列组

```sql
-- ❌ 违反1NF：重复列
| id | name | phone1      | phone2      | phone3      |
|----|------|-------------|-------------|-------------|
| 1  | 张三 | 13800138001 | 13800138002 | NULL        |
```

### 修复方法

```sql
-- ✅ 符合1NF
users: id, name
phones: id, user_id, phone_number, phone_type
```

---

## 第二范式 (2NF)：非主键列必须依赖完整主键

**仅在复合主键时需要检查**

### 检查标准

| 检查项 | Yes = 合规 |
|--------|-----------|
| 已满足1NF？ | ✅ |
| 复合主键时，每个非主键列都依赖整个主键？ | ✅ |

### 违规示例

```sql
-- ❌ 违反2NF：student_name只依赖student_id，不依赖course_id
| student_id | course_id | student_name | grade |
|------------|-----------|--------------|-------|
| 1          | 101       | 张三         | 85    |
| 1          | 102       | 张三         | 90    |  -- 张三重复！
```

问题分析：
- 复合主键: (student_id, course_id)
- student_name 只依赖 student_id，不依赖 course_id
- 这是**部分依赖**，违反 2NF

### 修复方法

```sql
-- ✅ 符合2NF
students: student_id, student_name
enrollments: student_id, course_id, grade
```

---

## 第三范式 (3NF)：非主键列之间不能有依赖

### 检查标准

| 检查项 | Yes = 合规 |
|--------|-----------|
| 已满足2NF？ | ✅ |
| 非主键列之间没有决定关系？ | ✅ |
| 每个非主键列只由主键决定？ | ✅ |

### 违规示例

```sql
-- ❌ 违反3NF：dept_name由dept_id决定，而非由emp_id决定
| emp_id | emp_name | dept_id | dept_name |
|--------|----------|---------|-----------|
| 1      | 张三     | D01     | 技术部    |
| 2      | 李四     | D01     | 技术部    |  -- 技术部重复！
```

问题分析：
- 主键: emp_id
- dept_name 由 dept_id 决定，而不是由 emp_id 直接决定
- 这是**传递依赖**: emp_id → dept_id → dept_name
- 违反 3NF

### 修复方法

```sql
-- ✅ 符合3NF
employees: emp_id, emp_name, dept_id
departments: dept_id, dept_name
```

---

## 快速识别不符合3NF的信号

**如果回答"是"，表可能需要规范化**：

| # | 问题 | 含义 |
|---|------|------|
| 1 | 更新一个值时需要更新多行？ | **数据冗余** |
| 2 | 删除某行会丢失其他有用信息？ | **删除异常** |
| 3 | 必须编造数据才能插入新记录？ | **插入异常** |
| 4 | 同样的信息出现在多个地方？ | **需要拆表** |
| 5 | 列名包含序号（如item1, item2）？ | **违反1NF** |
| 6 | 表超过30列且有很多NULL？ | **考虑拆分** |

---

## 规范化例外情况

以下情况可以适度反规范化：

1. **读多写少的报表表**：预计算的统计数据可以冗余存储
2. **高频查询的关联数据**：避免频繁JOIN的核心字段可以冗余
3. **审计日志表**：保存历史快照需要完整数据副本
4. **全文搜索字段**：搜索用的组合字段

**原则**：先规范化，遇到实际性能问题再考虑反规范化，并记录原因。

---

## 总结：核心规则速记

**规范化三句话**：
1. **1NF**：一格一值，无重复列
2. **2NF**：完全依赖，非部分依赖（针对复合主键）
3. **3NF**：直接依赖主键，非间接传递

**反模式三警报**：
1. 看到逗号分隔值 → 需要关联表
2. 看到phone1/phone2 → 需要子表
3. 看到X_id+X_name → X需要独立表
