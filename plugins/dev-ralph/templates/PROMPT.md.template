---
# dev-ralph Configuration

iteration_limit: 500      # Maximum iterations before auto-stop
verbosity: normal         # minimal | normal | verbose

# Build commands for this project
build_commands:
  type_check: "bun run type-check"   # Type checking command (fast backpressure)
  lint: "bun run lint"               # Linting command
  test: "bun run test"               # Test runner command
---

# PROMPT.md - Ralph Wiggum Implementation Loop

Based on Geoffrey Huntley's Ralph Wiggum technique.
Simple loop, file-based state, backpressure from tests.

## Core Principle: ONE ITEM PER ITERATION

Each iteration:
1. Read context (specs, stdlib, plan, lessons)
2. Pick the FIRST unchecked `[ ]` item
3. Implement it fully (following stdlib patterns!)
4. Run type-check (backpressure)
5. Mark it `[x]`
6. Append learnings to `lessons-learned.md` (if any)
7. Output: `<item>COMPLETE</item>`

The stop hook will re-feed this prompt for the next item.

When ALL items are done: output `<promise>VERIFIED_COMPLETE</promise>`

---

## Context Loading (DO THIS FIRST!)

Before implementing, READ these files in order:

### 1. Read Specs
Study `specs/*.md` for:
- Technical specifications (data models, API shapes)
- Requirements and edge cases
- Success criteria

### 2. Read Standard Library
Study `stdlib/*.md` for:
- Code patterns to follow (HOW to build)
- Anti-patterns to avoid
- Technical standards for this project

If stdlib is empty, that's OK. You can add patterns as you discover them.

### 3. Read Implementation Plan
Study `IMPLEMENTATION_PLAN.md` for:
- The FIRST unchecked `[ ]` item - **this is your task**
- Phase organization
- Progress so far

### 4. Read Signs (if exists)
Study `Signs.md` for:
- Hard-learned anti-patterns
- ALWAYS follow these

### 5. Read Lessons Learned (if exists)
Study `lessons-learned.md` for:
- Patterns that worked
- Errors to avoid
- Discovered requirements

---

## Your Task: Implement ONE Item

**DO NOT implement multiple items.** Just the first unchecked one.

### Step 1: Identify Your Task
Find the first unchecked `[ ]` item in IMPLEMENTATION_PLAN.md

### Step 2: Implement It Fully
- Write complete code (no placeholders!)
- Follow patterns from stdlib/*.md
- Apply lessons from lessons-learned.md
- Match spec requirements exactly

### Step 3: Backpressure
```bash
bun run type-check  # Must pass before moving on
```

If type-check fails, fix errors before continuing.

### Step 4: Mark Complete
Edit IMPLEMENTATION_PLAN.md: change `[ ]` to `[x]` for this item.

### Step 5: Append Learnings
If you discovered something useful (pattern, gotcha, fix), append it to `lessons-learned.md`:
```markdown
## [Item Name] - [Date]
- What worked: ...
- What to avoid: ...
- Pattern discovered: ...
```
Keep entries brief. Future iterations will read these.

### Step 6: Signal Done
Output this exact tag:
```
<item>COMPLETE</item>
```

The stop hook will detect this and re-feed the prompt for the next item.

---

## When All Items Are Done

After marking the LAST item `[x]`:
1. Verify all items are complete
2. Run final type-check
3. Output: `<promise>VERIFIED_COMPLETE</promise>`

---

## Anti-Cheating Rules

**NON-NEGOTIABLE:**

1. NO placeholder code (TODO, FIXME, stubs)
2. NO empty function bodies
3. NO unimplemented interfaces
4. FULL implementations only

If you cannot implement something:
- Document what's blocking you
- Ask the developer for help
- Do NOT fake it

---

## Backpressure

**Type-check is your validation.** Run it after each item.

If it fails → fix before moving on.
If it passes → item is done.

This is the "fast wheel" - quick feedback, iterate rapidly.

---

## Summary

```
┌─────────────────────────────────────────┐
│  ONE ITEM PER ITERATION                 │
│                                         │
│  1. Read context (specs, stdlib, plan)  │
│  2. Pick FIRST unchecked [ ] item       │
│  3. Implement (follow stdlib patterns)  │
│  4. Type-check (backpressure)           │
│  5. Mark [x]                            │
│  6. Append learnings (if any)           │
│  7. Output: <item>COMPLETE</item>       │
│                                         │
│  Loop feeds you next iteration.         │
│  When ALL done:                         │
│  <promise>VERIFIED_COMPLETE</promise>   │
└─────────────────────────────────────────┘
```

No agents. No complex signals. Just implement, verify, signal, repeat.
