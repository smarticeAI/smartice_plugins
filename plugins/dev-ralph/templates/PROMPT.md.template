---
# dev-ralph Configuration
# Customize these values based on your project

iteration_limit: 500      # Maximum iterations before auto-stop
retry_limit: 5            # Retries before asking developer for help
coverage_threshold: 80    # Test coverage percentage required
verbosity: normal         # minimal | normal | verbose

# Anti-cheat patterns (verification will grep for these)
placeholder_patterns:
  - "TODO"
  - "FIXME"
  - "unimplemented"
  - "NotImplementedError"
  - "throw new Error('Not implemented')"

# Build commands for this project
# Set these to match your project's toolchain
build_commands:
  type_check: "bun run type-check"   # Type checking command (TypeScript, Flow, mypy, etc.)
  lint: "bun run lint"               # Linting command (ESLint, Prettier, Ruff, etc.)
  test: "bun run test"               # Test runner command
  coverage: "bun run test:coverage"  # Test coverage command
  # test_discovery: "bun run test --listTests"  # Optional: list test files for discovery verification

# Integration patterns to verify (supports regex: prefix)
# These patterns are grepped in entry points to verify new code is wired in
integration_patterns:
  # Literal strings (exact match)
  # - "app.register"
  # - "router.post"
  # Regex patterns (prefix with "regex:")
  # - "regex:@(app|router)\\.(get|post|put|delete)"

# Entry points for integration verification
# List files where new modules should be imported/registered
# If empty, auto-detects based on project type (main.ts, app.py, etc.)
entry_points:
  # - "src/main.ts"
  # - "src/app.py"

# Categories excluded from integration checks
# Files in these categories don't require explicit import/usage verification
integration_exclusions:
  categories:
    # - utilities    # utils/, helpers/, lib/ directories
    # - types        # types/, *.d.ts, typing.py, *_types.py
    # - constants    # constants/, config/ directories

# Integration strictness: strict | warn | lenient
# - strict: Partial integration (import without usage) is a FAIL
# - warn: Partial integration is a WARNING, verification passes
# - lenient: Only check core integration (import exists), skip usage check
integration_strictness: warn
---

# PROMPT.md

This file is fed to Claude at the start of each iteration.

## Context Loading

Before starting work, study:

0a. Study `specs/*` including `specs/stdlib/*` for requirements
0b. Study `IMPLEMENTATION_PLAN.md` for current priorities
0c. The source code is in `src/`

## Build Order

**stdlib modules MUST be built BEFORE features.**

1. **stdlib First**: If `specs/stdlib/*.md` exists:
   - Build those modules first in `src/stdlib/`
   - Write tests for stdlib modules
   - Features will import from stdlib
   - Do NOT proceed to features until stdlib is complete

2. **Features Second**: After stdlib is complete:
   - Implement features in priority order
   - All features should use stdlib utilities
   - Don't duplicate stdlib functionality in features

3. **stdlib Updates**: If you discover a pattern that should be in stdlib:
   - Add to `src/stdlib/` first
   - Then use it in feature code
   - This keeps the codebase DRY

## Your Task

Pick the most important unfinished item from IMPLEMENTATION_PLAN.md and implement it.

**One item per iteration.** Focus on completing one task fully before moving to the next.

## Subagent Usage (Context Efficiency)

Your context window is precious. Use subagents to avoid filling it with search output.

### MUST Use Subagent (Task tool with subagent_type)
- **Searching across >5 files** → `subagent_type=Explore`
- **Finding all usages of a function** → `subagent_type=Explore`
- **Understanding unfamiliar code area** → `subagent_type=Explore`

### Direct Tools OK
- Reading a specific known file → Read tool
- Checking if a pattern exists in 1-2 files → Grep tool
- Listing files in a directory → Glob tool

### Example: Before Implementing Feature X

**DON'T** (fills your context):
```
Use Grep to search all .ts files for similar patterns...
[500 lines of output waste your context]
```

**DO** (preserves context):
```
Use Task tool with subagent_type=Explore:
"Find all existing implementations similar to Feature X,
 summarize patterns and locations"
→ Returns: 5-line summary with file:line references
```

## Additional Guidelines

- Mark completed items in IMPLEMENTATION_PLAN.md with `[x]`
- Use only 1 subagent for build/test operations (avoid parallel builds)
- Focus on one task per iteration

## Backpressure

After implementing, run the type checker:

```bash
bun run type-check
```

If errors occur, fix them before proceeding.

## Completion Protocol

When implementation is complete (type-check passes):

1. Output: `<status>IMPLEMENTATION_COMPLETE</status>`
2. This triggers the verification phase
3. Run the verification-auditor agent
4. If verification passes, output: `<promise>VERIFIED_COMPLETE</promise>`

## Anti-Cheating Rules

These are NON-NEGOTIABLE:

99999999999999. DO NOT IMPLEMENT PLACEHOLDERS.
99999999999998. NO TODO comments, no unimplemented stubs.
99999999999997. FULL IMPLEMENTATIONS ONLY OR I WILL YELL AT YOU.

If you cannot implement something:
- Ask the developer for help (after retry limit)
- Do NOT fake it with placeholder code
- Do NOT use empty function bodies
- Do NOT leave TODO comments

## Error Recovery

If stuck after multiple attempts:
1. Document what you tried
2. Document what went wrong
3. Ask the developer for guidance
4. Wait for response before continuing
